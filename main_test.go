package main

import (
	"io/fs"
	"net/http"
	"net/http/httptest"
	"os"
	"testing"
	"time"

	"github.com/stefanpenner/lcc-live/server"
	"github.com/stefanpenner/lcc-live/store"
	"github.com/stefanpenner/lcc-live/udot"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestLoadConfig(t *testing.T) {
	tests := []struct {
		name             string
		envPort          string
		envSyncInterval  string
		expectedPort     string
		expectedInterval time.Duration
	}{
		{
			name:             "defaults when no env vars",
			envPort:          "",
			envSyncInterval:  "",
			expectedPort:     "3000",
			expectedInterval: defaultSyncInterval,
		},
		{
			name:             "custom port",
			envPort:          "8080",
			envSyncInterval:  "",
			expectedPort:     "8080",
			expectedInterval: defaultSyncInterval,
		},
		{
			name:             "custom sync interval",
			envPort:          "",
			envSyncInterval:  "10s",
			expectedPort:     "3000",
			expectedInterval: 10 * time.Second,
		},
		{
			name:             "invalid sync interval falls back to default",
			envPort:          "",
			envSyncInterval:  "invalid",
			expectedPort:     "3000",
			expectedInterval: defaultSyncInterval,
		},
		{
			name:             "zero sync interval",
			envPort:          "",
			envSyncInterval:  "0",
			expectedPort:     "3000",
			expectedInterval: 0,
		},
		{
			name:             "both custom values",
			envPort:          "4000",
			envSyncInterval:  "5s",
			expectedPort:     "4000",
			expectedInterval: 5 * time.Second,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Clear and set environment
			os.Unsetenv("PORT")
			os.Unsetenv("SYNC_INTERVAL")
			if tt.envPort != "" {
				os.Setenv("PORT", tt.envPort)
				defer os.Unsetenv("PORT")
			}
			if tt.envSyncInterval != "" {
				os.Setenv("SYNC_INTERVAL", tt.envSyncInterval)
				defer os.Unsetenv("SYNC_INTERVAL")
			}

			config := loadConfig()

			assert.Equal(t, tt.expectedPort, config.Port)
			assert.Equal(t, tt.expectedInterval, config.SyncInterval)
		})
	}

	// Test consistency across multiple calls
	t.Run("multiple calls return same values", func(t *testing.T) {
		os.Setenv("PORT", "4000")
		os.Setenv("SYNC_INTERVAL", "5s")
		defer func() {
			os.Unsetenv("PORT")
			os.Unsetenv("SYNC_INTERVAL")
		}()

		config1 := loadConfig()
		config2 := loadConfig()

		assert.Equal(t, config1.Port, config2.Port)
		assert.Equal(t, config1.SyncInterval, config2.SyncInterval)
	})
}

func TestDefaultSyncInterval(t *testing.T) {
	assert.Equal(t, 3*time.Second, defaultSyncInterval)
}

func TestConfig_Structure(t *testing.T) {
	config := Config{
		Port:         "3000",
		SyncInterval: 5 * time.Second,
	}

	assert.Equal(t, "3000", config.Port)
	assert.Equal(t, 5*time.Second, config.SyncInterval)
}

// Test filesystem loading from disk
func TestFilesystemLoading(t *testing.T) {
	// Set up dev mode for testing
	os.Setenv("DEV_MODE", "1")
	defer os.Unsetenv("DEV_MODE")

	t.Run("Data file loads", func(t *testing.T) {
		dataFS, err := loadFilesystem(".")
		require.NoError(t, err)
		data, err := fs.ReadFile(dataFS, "data.json")
		require.NoError(t, err)
		assert.NotEmpty(t, data)
		assert.Contains(t, string(data), "lcc")
		assert.Contains(t, string(data), "bcc")
	})

	t.Run("Static files load", func(t *testing.T) {
		staticFS, err := loadFilesystem("static")
		require.NoError(t, err)

		files := []string{
			"script.mjs",
			"style.css",
		}

		for _, file := range files {
			data, err := fs.ReadFile(staticFS, file)
			require.NoError(t, err, "File %s should load", file)
			assert.NotEmpty(t, data, "File %s should not be empty", file)
		}

		// favicon.png is generated by Bazel build, skip if not present in dev mode
		_, err = fs.ReadFile(staticFS, "favicon.png")
		if err == nil {
			// File exists, verify it's not empty
			data, err := fs.ReadFile(staticFS, "favicon.png")
			require.NoError(t, err, "File favicon.png should load")
			assert.NotEmpty(t, data, "File favicon.png should not be empty")
		}
		// If file doesn't exist, that's okay - it's generated by Bazel
	})

	t.Run("Templates load", func(t *testing.T) {
		tmplFS, err := loadFilesystem("templates")
		require.NoError(t, err)
		data, err := fs.ReadFile(tmplFS, "canyon.html.tmpl")
		require.NoError(t, err)
		assert.NotEmpty(t, data)
		assert.Contains(t, string(data), "<!DOCTYPE")
	})
}

// Benchmark config loading
func BenchmarkLoadConfig(b *testing.B) {
	os.Setenv("PORT", "3000")
	os.Setenv("SYNC_INTERVAL", "5s")
	defer func() {
		os.Unsetenv("PORT")
		os.Unsetenv("SYNC_INTERVAL")
	}()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = loadConfig()
	}
}

// Integration test that validates the full application startup sequence
func TestApplicationStartup(t *testing.T) {
	// Set up dev mode for testing
	os.Setenv("DEV_MODE", "1")
	defer os.Unsetenv("DEV_MODE")

	// Test that store initializes from data.json
	t.Run("Store initializes from data.json", func(t *testing.T) {
		dataFS, err := loadFilesystem(".")
		require.NoError(t, err)

		testStore, err := store.NewStoreFromFile(dataFS, "data.json")
		require.NoError(t, err)
		assert.NotNil(t, testStore)

		// Verify canyons are loaded
		lcc := testStore.Canyon("LCC")
		bcc := testStore.Canyon("BCC")
		assert.NotEmpty(t, lcc.Name)
		assert.NotEmpty(t, bcc.Name)
	})

	// Test that server starts without errors
	t.Run("Server starts successfully", func(t *testing.T) {
		// Setup filesystem
		staticFS, err := loadFilesystem("static")
		require.NoError(t, err)

		tmplFS, err := loadFilesystem("templates")
		require.NoError(t, err)

		dataFS, err := loadFilesystem(".")
		require.NoError(t, err)

		// Create store
		testStore, err := store.NewStoreFromFile(dataFS, "data.json")
		require.NoError(t, err)

		// Start server
		app, err := server.Start(server.ServerConfig{
			Store:         testStore,
			StaticFS:      staticFS,
			TemplateFS:    tmplFS,
			DevMode:       false,
			SentryEnabled: false,
		})
		require.NoError(t, err)
		assert.NotNil(t, app)
	})

	// Integration test: full startup and basic route
	t.Run("Full startup and basic route works", func(t *testing.T) {
		// Setup filesystem
		staticFS, err := loadFilesystem("static")
		require.NoError(t, err)

		tmplFS, err := loadFilesystem("templates")
		require.NoError(t, err)

		dataFS, err := loadFilesystem(".")
		require.NoError(t, err)

		// Create and initialize store
		testStore, err := store.NewStoreFromFile(dataFS, "data.json")
		require.NoError(t, err)

		// Start server
		app, err := server.Start(server.ServerConfig{
			Store:         testStore,
			StaticFS:      staticFS,
			TemplateFS:    tmplFS,
			DevMode:       false,
			SentryEnabled: false,
		})
		require.NoError(t, err)

		// Test that routes are accessible (even if images not yet fetched)
		// The healthcheck should return 503 if images aren't ready
		req := httptest.NewRequest("GET", "/healthcheck", nil)
		rec := httptest.NewRecorder()
		app.ServeHTTP(rec, req)

		// Should be 503 since we haven't fetched images yet
		assert.Equal(t, http.StatusServiceUnavailable, rec.Code)
	})
}

func TestFilterEventsByCanyon(t *testing.T) {
	tests := []struct {
		name    string
		event   store.Event
		wantLCC bool
		wantBCC bool
	}{
		{
			name:    "LCC - SR-210 in roadway name",
			event:   store.Event{RoadwayName: "SR-210"},
			wantLCC: true,
			wantBCC: false,
		},
		{
			name:    "LCC - SR 210 in roadway name",
			event:   store.Event{RoadwayName: "SR 210"},
			wantLCC: true,
			wantBCC: false,
		},
		{
			name:    "LCC - State Route 210",
			event:   store.Event{RoadwayName: "State Route 210"},
			wantLCC: true,
			wantBCC: false,
		},
		{
			name:    "LCC - Little Cottonwood in location",
			event:   store.Event{Location: "Little Cottonwood Canyon"},
			wantLCC: true,
			wantBCC: false,
		},
		{
			name:    "LCC - 210 with SR context",
			event:   store.Event{RoadwayName: "SR-210 near Alta"},
			wantLCC: true,
			wantBCC: false,
		},
		{
			name:    "BCC - SR-190 in roadway name",
			event:   store.Event{RoadwayName: "SR-190"},
			wantLCC: false,
			wantBCC: true,
		},
		{
			name:    "BCC - Big Cottonwood in description",
			event:   store.Event{Description: "Roadwork on Big Cottonwood Canyon"},
			wantLCC: false,
			wantBCC: true,
		},
		{
			name:    "Neither - I-210 (not SR-210)",
			event:   store.Event{RoadwayName: "I-210"},
			wantLCC: false,
			wantBCC: false,
		},
		{
			name:    "Neither - US-190 (not SR-190)",
			event:   store.Event{RoadwayName: "US-190"},
			wantLCC: false,
			wantBCC: false,
		},
		{
			name:    "Neither - standalone 210 without context",
			event:   store.Event{RoadwayName: "Highway 210"},
			wantLCC: false,
			wantBCC: false,
		},
		{
			name:    "Neither - unrelated highway",
			event:   store.Event{RoadwayName: "I-15"},
			wantLCC: false,
			wantBCC: false,
		},
		{
			name: "Both - event mentions both canyons",
			event: store.Event{
				RoadwayName: "SR-210",
				Description: "Near Big Cottonwood Canyon",
			},
			wantLCC: true,
			wantBCC: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			lccEvents, bccEvents := udot.FilterEventsByCanyon([]store.Event{tt.event})

			if tt.wantLCC {
				assert.Len(t, lccEvents, 1, "should match LCC")
				assert.Equal(t, tt.event.ID, lccEvents[0].ID)
			} else {
				assert.Len(t, lccEvents, 0, "should not match LCC")
			}

			if tt.wantBCC {
				assert.Len(t, bccEvents, 1, "should match BCC")
				assert.Equal(t, tt.event.ID, bccEvents[0].ID)
			} else {
				assert.Len(t, bccEvents, 0, "should not match BCC")
			}
		})
	}
}
